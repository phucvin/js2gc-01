Summary: Implemented closure support in the compiler.
This session involved modifying the compiler to support function expressions (lambdas) and variable capturing.
Key changes:

1.  **Context**: Updated `CompilationContext` to support nested scopes (`parent` link) and tracking of captured variables (`captured` set).
2.  **Closures**: Defined `$Closure` struct in `index.ts`. Implemented `compileFunctionExpression` in `expression.ts` which generates a new top-level function for the closure and constructs a `$Closure` struct with the environment.
3.  **Environment**: Captured variables are stored in an `$Object` which acts as the environment. This object is populated at closure creation time (capture-by-value).
4.  **Invocation**: Updated `CallExpression` handling to support calling closures using `call_ref` with explicit casting.
5.  **Determinism**: Replaced `Math.random()` with a deterministic `closureCounter` for generating unique function names.

# User Prompt

support closure

the captured environment for a closure can simply be an object containing fields as the variables accessed by the closure

also follow agents.md

# Agent Response

I have implemented closure support.

1.  **Modified `src/compiler/context.ts`**: Added support for nested contexts and variable lookup across scopes.
2.  **Modified `src/compiler/index.ts`**: Added `$Closure` type definition and closure signature definitions. Added support for appending generated closure functions to the module.
3.  **Modified `src/compiler/expression.ts`**:
    - Implemented `compileFunctionExpression` to handle `ArrowFunction` and `FunctionExpression`. It analyzes captured variables, creates an environment object, and generates a helper function.
    - Updated `compileExpression` to handle `CallExpression` for closures by extracting the function and environment and using `call_ref`.
    - Used a deterministic counter for generating closure function names.
4.  **Created `testdata/closure.js`**: Verified the implementation with a test case involving variable capture and execution.

The implementation captures variables by value (snapshot) at the time of closure creation, storing them in an environment object.
